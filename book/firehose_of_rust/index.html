<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Firehose of Rust - The Rust Cheat Sheet</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../strings/index.html"><strong aria-hidden="true">1.</strong> Strings</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../strings/find.html"><strong aria-hidden="true">1.1.</strong> Find From Starting Point</a></li></ol></li><li class="chapter-item expanded "><a href="../cargo/index.html"><strong aria-hidden="true">2.</strong> Cargo</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../cargo/test/index.html"><strong aria-hidden="true">2.1.</strong> Test</a></li><li class="chapter-item expanded "><a href="../cargo/cargo-edit/index.html"><strong aria-hidden="true">2.2.</strong> cargo-edit</a></li></ol></li><li class="chapter-item expanded "><a href="../external_crates/index.html"><strong aria-hidden="true">3.</strong> External Crates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../external_crates/clap/index.html"><strong aria-hidden="true">3.1.</strong> Clap</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../external_crates/clap/derive_api_pattern.html"><strong aria-hidden="true">3.1.1.</strong> Derive API Pattern</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../webdev/index.html"><strong aria-hidden="true">4.</strong> Web Dev</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../webdev/access_web_dom.html"><strong aria-hidden="true">4.1.</strong> Access Web DOM</a></li></ol></li><li class="chapter-item expanded "><a href="../good_resources/index.html"><strong aria-hidden="true">5.</strong> Good Resources</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../good_resources/are_we_web_yet/index.html"><strong aria-hidden="true">5.1.</strong> Are we web yet?</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../good_resources/are_we_web_yet/web_assembly.html"><strong aria-hidden="true">5.1.1.</strong> Web Assembly</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../firehose_of_rust/index.html" class="active"><strong aria-hidden="true">6.</strong> Firehose of Rust</a></li><li class="chapter-item expanded "><a href="../references.html"><strong aria-hidden="true">7.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Rust Cheat Sheet</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="firehose-of-rust"><a class="header" href="#firehose-of-rust">Firehose of Rust</a></h1>
<h2 id="first-of-all-credits"><a class="header" href="#first-of-all-credits">First of all, credits</a></h2>
<p>credit goes to: <code>Jack O'Connor</code></p>
<p>materials included in this cheat sheet</p>
<ul>
<li><a href="https://jacko.io/firehose_of_rust"><code>slides</code></a></li>
<li><a href="https://www.youtube.com/watch?v=FSyfZVuD32Y"><code>presentation</code></a></li>
</ul>
<h1 id="a-dangling-pointer-in-rust"><a class="header" href="#a-dangling-pointer-in-rust">A Dangling Pointer in Rust</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_int_ptr: &amp;i32;
{
    let my_int: i32 = 5;
    my_int_ptr = &amp;my_int;
}
dbg!(*my_int_ptr);
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0597]: `my_int` does not live long enough
 --&gt; examples/firehose_dangling_pointer.rs:7:22
  |
7 |         my_int_ptr = &amp;my_int;
  |                      ^^^^^^^ borrowed value does not live long enough
8 |     }
  |     - `my_int` dropped here while still borrowed
9 |     dbg!(*my_int_ptr);
  |          ----------- borrow later used here

For more information about this error, try `rustc --explain E0597`.
error: could not compile `cheat-sheet` due to previous error
</code></pre>
<p>solution to fix this:</p>
<pre><code class="language-shell">you dont make to things that dont live long enough
</code></pre>
<h1 id="a-borrowing-view"><a class="header" href="#a-borrowing-view">A borrowing view</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_string: String =
    &quot;abcdefghijklmnopqrstuvwxy&quot;.to_string();
let my_string_view: &amp;str = (my_string + &quot;z&quot;).as_str();
dbg!(my_string_view);
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0716]: temporary value dropped while borrowed
 --&gt; src/main.rs:5:9
  |
5 |         (my_string + &quot;z&quot;).as_str();
  |         ^^^^^^^^^^^^^^^^^         - temporary value is freed at the end of this statement
  |         |
  |         creates a temporary which is freed while still in use
6 |     dbg!(my_string_view);
  |          -------------- borrow later used here
  |
  = note: consider using a `let` binding to create a longer lived value
</code></pre>
<p>solution to fix this: you put the temp value into a variable</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_string: String =
    &quot;abcdefghijklmnopqrstuvwxy&quot;.to_string();
let temp_value_not_temp_anymore = my_string + &quot;z&quot;;
let my_string_view: &amp;str = temp_value_not_temp_anymore.as_str();
// what if i drop `temp_value_not_temp_anymore` here
// drop(temp_value_not_temp_anymore);
dbg!(my_string_view);
<span class="boring">}
</span></code></pre></pre>
<h1 id="a-long-lived-container"><a class="header" href="#a-long-lived-container">A long lived container</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_vector: Vec&lt;&amp;str&gt; = Vec::new();
{
    let my_string = &quot;hello world&quot;.to_string();
    my_vector.push(&amp;my_string);
}
dbg!(my_vector);
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0597]: `my_string` does not live long enough
 --&gt; src/main.rs:5:24
  |
5 |         my_vector.push(&amp;my_string);
  |                        ^^^^^^^^^^ borrowed value does not live long enough
6 |     }
  |     - `my_string` dropped here while still borrowed
7 |     dbg!(my_vector);
  |          --------- borrow later used here
</code></pre>
<h1 id="an-invalid-function"><a class="header" href="#an-invalid-function">An invalid function</a></h1>
<pre><pre class="playground"><code class="language-rust">fn my_push_back(v: &amp;mut Vec&lt;&amp;str&gt;, s: &amp;str) {
    v.push(s);
}

fn main() {
    let mut my_vector: Vec&lt;&amp;str&gt; = Vec::new();
    {
        let my_string = &quot;hello world&quot;.to_string();
        my_push_back(&amp;mut my_vector, &amp;my_string);
    }
    dbg!(my_vector);
}
</code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0623]: lifetime mismatch
 --&gt; src/main.rs:2:12
  |
1 | fn my_push_back(v: &amp;mut Vec&lt;&amp;str&gt;, s: &amp;str) {
  |                             ----      ---- these two types are declared with different lifetimes...
2 |     v.push(s);
  |            ^ ...but data from `s` flows into `v` here
</code></pre>
<p>rust analyses the function first. it assumes the s reference doesnt live long enough to be put in the <code>v</code> container and that is very corect. it could really happen, as presented in the above code.</p>
<p>solution to fix this: add explicit lifetimes</p>
<pre><pre class="playground"><code class="language-rust">fn my_push_back&lt;'a&gt;(v: &amp;mut Vec&lt;&amp;'a str&gt;, s: &amp;'a str) {
    v.push(s);
}

fn main() {
    let mut my_vector: Vec&lt;&amp;str&gt; = Vec::new();
    {
        let my_string = &quot;hello world&quot;.to_string();
        my_push_back(&amp;mut my_vector, &amp;my_string);
    }
    dbg!(my_vector);
}
</code></pre></pre>
<p>NOTE: this doesnt fix the code, these explicit lifetimes only fix the function
the error still remains</p>
<pre><code class="language-shell">error[E0597]: `my_string` does not live long enough
  --&gt; src/main.rs:9:38
   |
9  |         my_push_back(&amp;mut my_vector, &amp;my_string);
   |                                      ^^^^^^^^^^ borrowed value does not live long enough
10 |     }
   |     - `my_string` dropped here while still borrowed
11 |     dbg!(my_vector);
   |          --------- borrow later used here
</code></pre>
<p>same thing as first example with pointer, cannot have reference to something that was deallocated from the memory</p>
<p>explanation: the elements in the vector and new element that will arive in the vector <code>must</code> have the same lifetime, meaning: they must have the same life span</p>
<p>think of 2 people with different ages. for example, 4 this to work, both people must die at the same time or have both 70 years of lifespan for example.</p>
<p>you cannot have 2 people with one dying sooner than the other. same principle to references in rust</p>
<h1 id="mutable-aliasing"><a class="header" href="#mutable-aliasing">Mutable aliasing</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_int = 5;
let reference1 = &amp;mut my_int;
let reference2 = &amp;mut my_int;
*reference1 += 1;
*reference2 += 1;
assert_eq!(my_int, 7);
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0499]: cannot borrow `my_int` as mutable more than once at a time
 --&gt; src/main.rs:4:22
  |
3 |     let reference1 = &amp;mut my_int;
  |                      ----------- first mutable borrow occurs here
4 |     let reference2 = &amp;mut my_int;
  |                      ^^^^^^^^^^^ second mutable borrow occurs here
5 |     *reference1 += 1;
  |     ---------------- first borrow later used here
</code></pre>
<h1 id="multiple-references-into-an-array"><a class="header" href="#multiple-references-into-an-array">Multiple references into an array</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut char_array: [char; 2] = ['a', 'b'];
let first_element = &amp;mut char_array[0];
let second_element = &amp;char_array[1];
*first_element = *second_element;
assert_eq!(char_array[0], 'b');
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0502]: cannot borrow `char_array[_]` as immutable because it is also borrowed as mutable
 --&gt; src/main.rs:6:26
  |
5 |     let first_element = &amp;mut char_array[0];
  |                         ------------------ mutable borrow occurs here
6 |     let second_element = &amp;char_array[1];
  |                          ^^^^^^^^^^^^^^ immutable borrow occurs here
7 |     *first_element = *second_element;
  |     -------------------------------- mutable borrow later used here
</code></pre>
<p>solution to this:</p>
<ol>
<li><code>split_at_mut</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut char_array: [char; 2] = ['a', 'b'];
let (first_slice, rest_slice) =
    char_array.split_at_mut(1);
let first_element = &amp;mut first_slice[0];
let second_element = &amp;rest_slice[0];
*first_element = *second_element;
assert_eq!(char_array[0], 'b');
<span class="boring">}
</span></code></pre></pre>
<ol start="2">
<li><code>unsafe code</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut char_array: [char; 2] = ['a', 'b'];
let first_element: *mut char = &amp;mut char_array[0];
let second_element: *const char = &amp;char_array[1];
unsafe {
    *first_element = *second_element;
}
assert_eq!(char_array[0], 'b');
<span class="boring">}
</span></code></pre></pre>
<h1 id="invalidating-a-reference-by-reallocating"><a class="header" href="#invalidating-a-reference-by-reallocating">Invalidating a reference by reallocating</a></h1>
<pre><pre class="playground"><code class="language-rust">fn push_int_twice(v: &amp;mut Vec&lt;i32&gt;, n: &amp;i32) {
    v.push(*n);
    v.push(*n);
}

fn main() {
    let mut my_vector = vec![0];
    let my_int_reference = &amp;my_vector[0];
    push_int_twice(&amp;mut my_vector, my_int_reference);
}
</code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0502]: cannot borrow `my_vector` as mutable because it is also borrowed as immutable
  --&gt; src/main.rs:12:20
   |
11 |     let my_int_reference = &amp;my_vector[0];
   |                             --------- immutable borrow occurs here
12 |     push_int_twice(&amp;mut my_vector, my_int_reference);
   |                    ^^^^^^^^^^^^^^  ---------------- immutable borrow later used here
   |                    |
   |                    mutable borrow occurs here
</code></pre>
<h1 id="magical-multi-threading"><a class="header" href="#magical-multi-threading">Magical multi-threading</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// serial for loop
let mut v: Vec&lt;i32&gt; = vector_of_ints();
for x in &amp;mut v {
    *x += 1;
}


// serial for_each
let mut v: Vec&lt;i32&gt; = vector_of_ints();
v.iter_mut().for_each(|x| {
    *x += 1;
});


// Rayon parallel for_each
let mut v: Vec&lt;i32&gt; = vector_of_ints();
v.par_iter_mut().for_each(|x| {
    *x += 1;
});
<span class="boring">}
</span></code></pre></pre>
<p>this code is very fine, every <code>x</code> is incremented on its <code>thread</code>, fine, no data race</p>
<h1 id="tragical-multithreading"><a class="header" href="#tragical-multithreading">Tragical multithreading</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// serial for loop
let mut v: Vec&lt;i32&gt; = vector_of_ints();
let mut sum = 0;
for x in &amp;mut v {
    *x += 1;
    sum += *x;
}
// very fine


// serial for_each
let mut v: Vec&lt;i32&gt; = vector_of_ints();
let mut sum = 0;
v.iter_mut().for_each(|x| {
    *x += 1;
    sum += *x;
});
// very fine


// Rayon parallel for_each
let mut v: Vec&lt;i32&gt; = vector_of_ints();
let mut sum = 0;
v.par_iter_mut().for_each(|x| {
    *x += 1;
    sum += *x;
});
// not fine
// compile error, data race
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">   error[E0594]: cannot assign to `sum`, as it is a captured variable in a `Fn` closure
  --&gt; src/main.rs:62:9
   |
62 |         sum += *x;
   |         ^^^^^^^^^ cannot assign
</code></pre>
<h2 id="how-does-rust-know-about-that-sum-error"><a class="header" href="#how-does-rust-know-about-that-sum-error">How does Rust know? about that sum error</a></h2>
<h3 id="serial-iterator"><a class="header" href="#serial-iterator">Serial Iterator</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn for_each&lt;F&gt;(self, f: F)
where
    Self: Sized,
    F: FnMut(Self::Item),
{
    #[inline]
    fn call&lt;T&gt;(
        mut f: impl FnMut(T),
    ) -&gt; impl FnMut((), T) {
        move |(), item| f(item)
    }
    self.fold((), call(f));
}
<span class="boring">}
</span></code></pre></pre>
<p><code>Fn</code> is not <code>FnMut</code>, in the prev example rust expected <code>FnMut</code></p>
<h3 id="paralleliterator"><a class="header" href="#paralleliterator">ParallelIterator</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn for_each&lt;OP&gt;(self, op: OP)
where
    OP: Fn(Self::Item) + Sync + Send,
{
    for_each::for_each(self, &amp;op)
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="synchronizing-shared-state"><a class="header" href="#synchronizing-shared-state">Synchronizing shared state</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// using AtomicI32
let mut v: Vec&lt;i32&gt; = vector_of_ints();
let sum: AtomicI32 = AtomicI32::new(0);
v.par_iter_mut().for_each(|x| {
    *x += 1;
    sum.fetch_add(*x, Ordering::Relaxed);
});


// using Mutex&lt;i32&gt;
let mut v: Vec&lt;i32&gt; = vector_of_ints();
let sum: Mutex&lt;i32&gt; = Mutex::new(0);
v.par_iter_mut().for_each(|x| {
    *x += 1;
    let mut guard: MutexGuard&lt;i32&gt; = sum.lock().unwrap();
    *guard += *x;
});
<span class="boring">}
</span></code></pre></pre>
<p>this code is very fine</p>
<h1 id="moving-a-string"><a class="header" href="#moving-a-string">Moving a string</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = &quot;abcdefghijklmnopqrstuvwxyz&quot;.to_string();
let s2 = s1; // its moved,
let mut v = Vec::new();
v.push(s2); // its moved
// here v goes out of scope, only the destructor of v is called
<span class="boring">}
</span></code></pre></pre>
<p>one string allocation, one string destructor, how ?
well, look at the comments</p>
<h1 id="copying-a-string"><a class="header" href="#copying-a-string">Copying a string</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = &quot;abcdefghijklmnopqrstuvwxyz&quot;.to_string();
let s2 = s1.clone();
let mut v = Vec::new();
v.push(s2.clone());
<span class="boring">}
</span></code></pre></pre>
<p>three string allocations, three string destructors, because you copy that data inside the <code>String</code></p>
<h1 id="accessing-a-moved-from-object"><a class="header" href="#accessing-a-moved-from-object">Accessing a moved-from object</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = &quot;abcdefghijklmnopqrstuvwxyz&quot;.to_string();
let s2 = s1;
dbg!(s1);
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0382]: use of moved value: `s1`
  --&gt; src/main.rs:26:14
   |
24 |         let s1 = &quot;abcdefghijklmnopqrstuvwxyz&quot;.to_string();
   |             -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
25 |         let s2 = s1;
   |                  -- value moved here
26 |         dbg!(s1);
   |              ^^ value used here after move
</code></pre>
<p>s1 its gone, you cannot use it anymore</p>
<h1 id="moving-a-borrowed-object"><a class="header" href="#moving-a-borrowed-object">Moving a borrowed object</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = &quot;abcde&quot;.to_string();
let my_view = s1.as_str();
let s2 = s1;
dbg!(my_view);
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0505]: cannot move out of `s1` because it is borrowed
  --&gt; src/main.rs:31:18
   |
30 |         let my_view = s1.as_str();
   |                       -- borrow of `s1` occurs here
31 |         let s2 = s1;
   |                  ^^ move out of `s1` occurs here
32 |         dbg!(my_view);
   |              ------- borrow later used here
</code></pre>
<h1 id="moving-a-string-again"><a class="header" href="#moving-a-string-again">Moving a string again</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let s1 = &quot;abcdefghijklmnopqrstuvwxyz&quot;.to_string();
let s2 = s1;
let mut v = Vec::new();
v.push(s2);
let s3 = v[0];
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0507]: cannot move out of index of `Vec&lt;String&gt;`
  --&gt; src/main.rs:86:18
   |
86 |         let s3 = v[0];
   |                  ^^^^
   |                  |
   |                  move occurs because value has type `String`, which does not implement the `Copy` trait
   |                  help: consider borrowing here: `&amp;v[0]`
</code></pre>
<h3 id="another-example"><a class="header" href="#another-example">another example</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(s1: &amp;mut String) {
    let s2 = *s1;
    dbg!(s2);
}

fn g() {
    let mut s1 = &quot;foo&quot;.to_string();
    f(&amp;mut s1);
    dbg!(s1);
}
<span class="boring">}
</span></code></pre></pre>
<pre><code class="language-shell">error[E0507]: cannot move out of `*s1` which is behind a mutable reference
 --&gt; src/main.rs:7:14
  |
7 |     let s2 = *s1;
  |              ^^^
  |              |
  |              move occurs because `*s1` has type `String`, which does not implement the `Copy` trait
  |              help: consider borrowing here: `&amp;*s1`
</code></pre>
<h2 id="how-to-fix"><a class="header" href="#how-to-fix">how to fix</a></h2>
<h3 id="memswap"><a class="header" href="#memswap">mem::swap</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(s1: &amp;mut String) {
    let mut s2 = &quot;&quot;.to_string();
    mem::swap(s1, &amp;mut s2);
    dbg!(s2);
}

fn g() {
    let mut s1 = &quot;foo&quot;.to_string();
    f(&amp;mut s1);
    dbg!(s1);
}
<span class="boring">}
</span></code></pre></pre>
<p>s1 == &quot;&quot;
s2 == &quot;foo&quot;</p>
<h3 id="optiontake"><a class="header" href="#optiontake">Option::take</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(s1: &amp;mut Option&lt;String&gt;) {
    let s2 = s1.take().unwrap();
    dbg!(s2);
}

fn g() {
    let mut s1: Option&lt;String&gt; =
        Some(&quot;foo&quot;.to_string());
    f(&amp;mut s1);
    dbg!(s1);
}
<span class="boring">}
</span></code></pre></pre>
<p>s1 == None
s2 == &quot;foo&quot;</p>
<h3 id="vecremove"><a class="header" href="#vecremove">Vec::remove</a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn f(v: &amp;mut Vec&lt;String&gt;) {
    let s2 = v.remove(0);
    dbg!(s2);
}

fn g() {
    let mut v = vec![
        &quot;foo&quot;.to_string(),
        &quot;bar&quot;.to_string(),
        &quot;baz&quot;.to_string(),
    ];
    f(&amp;mut v);
    dbg!(v);
}
<span class="boring">}
</span></code></pre></pre>
<p>v == [&quot;bar&quot;, &quot;baz&quot;]
s2 == &quot;foo&quot;</p>
<h1 id="the-drop-function"><a class="header" href="#the-drop-function">The drop function</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let file = File::open(&quot;/dev/null&quot;)?;
drop(file);
<span class="boring">}
</span></code></pre></pre>
<h2 id="surprise-drop-is-the-empty-function"><a class="header" href="#surprise-drop-is-the-empty-function">Surprise: drop is the empty function</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn drop&lt;T&gt;(_x: T) {}
<span class="boring">}
</span></code></pre></pre>
<h1 id="putting-it-all-together"><a class="header" href="#putting-it-all-together">Putting it all together</a></h1>
<p><code>Arc&lt;Mutex&lt;String&gt;&gt;</code></p>
<h1 id="a-mutex-on-the-stack"><a class="header" href="#a-mutex-on-the-stack">A mutex on the stack</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_string: Mutex&lt;String&gt; = Mutex::new(String::new());
let mut thread_handles = Vec::new();
for _ in 0..10 {
    let thread_handle = thread::spawn(|| {
        let mut guard: MutexGuard&lt;String&gt; =
            my_string.lock().unwrap();
        guard.push_str(&quot;some characters&quot;);
    });
    thread_handles.push(thread_handle);
}
for thread_handle in thread_handles {
    thread_handle.join().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0373]: closure may outlive the current function, but it borrows `my_string`, which is owned by the current function
  --&gt; src/main.rs:9:43
   |
9  |         let thread_handle = thread::spawn(|| {
   |                                           ^^ may outlive borrowed value `my_string`
10 |             let mut guard: MutexGuard&lt;String&gt; =
11 |                 my_string.lock().unwrap();
   |                 --------- `my_string` is borrowed here
   |
</code></pre>
<h2 id="how-does-rust-know"><a class="header" href="#how-does-rust-know">How does Rust know?</a></h2>
<p>for_each</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn for_each&lt;OP&gt;(self, op: OP)
where
    OP: Fn(Self::Item) + Sync + Send,
{
    for_each::for_each(self, &amp;op)
}
<span class="boring">}
</span></code></pre></pre>
<p>spawn</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn spawn&lt;F, T&gt;(f: F) -&gt; JoinHandle&lt;T&gt;
where
    F: FnOnce() -&gt; T,
    F: Send + 'static,
    T: Send + 'static,
{
    Builder::new()
        .spawn(f)
        .expect(&quot;failed to spawn thread&quot;)
}
<span class="boring">}
</span></code></pre></pre>
<h1 id="a-mutex-on-the-heap"><a class="header" href="#a-mutex-on-the-heap">A mutex on the heap</a></h1>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_string: Arc&lt;Mutex&lt;String&gt;&gt; =
    Arc::new(Mutex::new(String::new()));
let mut thread_handles = Vec::new();
for _ in 0..10 {
    let arc_clone = my_string.clone();
    let thread_handle = thread::spawn(move || {
        let mut guard: MutexGuard&lt;String&gt; =
            arc_clone.lock().unwrap();
        guard.push_str(&quot;some characters&quot;);
    });
    thread_handles.push(thread_handle);
}
for thread_handle in thread_handles {
    thread_handle.join().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="forgetting-the-mutex"><a class="header" href="#forgetting-the-mutex">forgetting the mutex</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_string: Arc&lt;String&gt; = Arc::new(String::new());
let mut thread_handles = Vec::new();
for _ in 0..10 {
    let mut arc_clone = my_string.clone();
    let thread_handle = thread::spawn(move || {
        arc_clone.push_str(&quot;some characters&quot;);
    });
    thread_handles.push(thread_handle);
}
for thread_handle in thread_handles {
    thread_handle.join().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0596]: cannot borrow data in an `Arc` as mutable
  --&gt; src/main.rs:46:13
   |
46 |             arc_clone.push_str(&quot;some characters&quot;);
   |             ^^^^^^^^^ cannot borrow as mutable
   |
   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `Arc&lt;String&gt;`
</code></pre>
<h2 id="writing-under-a-read-lock"><a class="header" href="#writing-under-a-read-lock">Writing under a read lock</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_string: Arc&lt;RwLock&lt;String&gt;&gt; =
    Arc::new(RwLock::new(String::new()));
let mut thread_handles = Vec::new();
for _ in 0..10 {
    let arc_clone = my_string.clone();
    let thread_handle = thread::spawn(move || {
        let mut guard: RwLockReadGuard&lt;String&gt; =
            arc_clone.read().unwrap();
        guard.push_str(&quot;some characters&quot;);
    });
    thread_handles.push(thread_handle);
}
for thread_handle in thread_handles {
    thread_handle.join().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0596]: cannot borrow data in a dereference of `RwLockReadGuard&lt;'_, String&gt;` as mutable
  --&gt; src/main.rs:65:13
   |
65 |             guard.push_str(&quot;some characters&quot;);
   |             ^^^^^ cannot borrow as mutable
   |
   = help: trait `DerefMut` is required to modify through a dereference, but it is not implemented for `RwLockReadGuard&lt;'_, String&gt;`
</code></pre>
<h2 id="rust-giveth-and-rust-taketh-away"><a class="header" href="#rust-giveth-and-rust-taketh-away">Rust giveth and Rust taketh away</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_string: Arc&lt;Mutex&lt;String&gt;&gt; =
    Arc::new(Mutex::new(String::new()));

let mut thread_handles = Vec::new();

for _ in 0..10 {
    let arc_clone = my_string.clone();
    let thread_handle = thread::spawn(move || {
        let mut guard = arc_clone.lock().unwrap();
        let smuggled_ptr: &amp;mut String = &amp;mut *guard;
        drop(guard);
        smuggled_ptr.push_str(&quot;some characters&quot;);
    });
    thread_handles.push(thread_handle);
}

for thread_handle in thread_handles {
    thread_handle.join().unwrap();
}
<span class="boring">}
</span></code></pre></pre>
<p>after run</p>
<pre><code class="language-shell">error[E0505]: cannot move out of `guard` because it is borrowed
  --&gt; src/main.rs:84:18
   |
83 |             let smuggled_ptr: &amp;mut String = &amp;mut *guard;
   |                                                   ----- borrow of `guard` occurs here
84 |             drop(guard);
   |                  ^^^^^ move out of `guard` occurs here
85 |             smuggled_ptr.push_str(&quot;some characters&quot;);
   |             ------------ borrow later used here
</code></pre>
<p>simple error for such a complicated thing huh ?</p>
<h1 id="special-thanks"><a class="header" href="#special-thanks">Special Thanks</a></h1>
<p>to <code>Jack O'Connor</code></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../good_resources/are_we_web_yet/web_assembly.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../references.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../good_resources/are_we_web_yet/web_assembly.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../references.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
